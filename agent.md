# 아키텍처 설계 및 상태 관리 리팩터링

## 1. 의사결정 사항

### Zustand 도입
- **선택 이유**: `useState` 기반의 지역 상태 관리는 컴포넌트 간의 상태 공유를 복잡하게 만들고, props drilling 문제를 야기합니다. 특히 주문 목록(`orderItems`)과 같이 여러 컴포넌트(메뉴, 주문 요약, 결제 등)에서 접근해야 하는 상태는 전역적으로 관리하는 것이 효율적입니다.
- Zustand는 다음과 같은 장점을 제공하여 선택되었습니다.
  - **단순성**: Redux나 MobX에 비해 API가 매우 간단하고 직관적입니다.
  - **최소한의 보일러플레이트**: 스토어와 액션을 정의하는 코드가 매우 간결합니다.
  - **훅 기반 API**: React 훅과 자연스럽게 통합되어 사용이 편리합니다.
  - **성능**: 불필요한 리렌더링을 최소화하는 최적화 기능이 내장되어 있습니다.

### `functionCalling.ts` 유틸리티 파일 설계
- **역할**: 이 파일은 애플리케이션의 비즈니스 로직(API 통신, 데이터 처리 등)을 UI 로직과 분리하기 위해 생성되었습니다. 향후 메뉴 데이터 조회, 주문 및 결제 처리 등 외부 API와의 통신을 담당하는 함수들이 이 파일에 위치하게 됩니다.
- **설계 구조**:
  - `functionCalling.ts`는 Zustand 스토어를 직접 구독(`subscribe`)할 수 있도록 설계되었습니다.
  - 이를 통해 API 응답과 같은 비동기 이벤트가 발생했을 때, UI 컴포넌트를 거치지 않고 직접 전역 상태를 업데이트할 수 있습니다.
  - 이러한 구조는 **관심사 분리(Separation of Concerns)** 원칙을 따르며, 코드의 응집도를 높이고 테스트 용이성을 향상시킵니다.

## 2. 가정
- **`OrderItem` 타입 정의**: 리팩터링 과정에서 `src/shared/types/order.ts` 파일에 `OrderItem` 타입이 `MenuItem`을 확장하여 `quantity` 속성을 포함하는 형태로 정의되었다고 가정했습니다.
- **API 연동**: 현재는 실제 API가 없으므로, `functionCalling.ts` 파일은 스토어 구독을 설정하고 향후 API 연동을 위한 기반을 마련하는 역할만 수행합니다.

## 3. 새로운 아키텍처 개요

### 상태 흐름 (State Flow)

새로운 아키텍처의 상태 흐름은 다음과 같습니다.

```
1. UI 컴포넌트 (예: MenuCard)
   |
   v
2. Zustand 스토어 액션 호출 (예: addItem)
   |
   v
3. Zustand 스토어 상태 변경 (orderItems 업데이트)
   |
   v
4. 스토어를 구독하는 모든 컴포넌트 리렌더링 (예: OrderSummary)
```

### 비동기 로직 흐름 (Function Calling)

`functionCalling.ts`를 통한 비동기 로직의 흐름은 다음과 같습니다.

```
1. 외부 이벤트 발생 (예: 서버로부터 메뉴 업데이트 푸시)
   |
   v
2. `functionCalling.ts` 내 API 핸들러 호출
   |
   v
3. Zustand 스토어 액션 직접 호출
   |
   v
4. 스토어 상태 변경 및 UI 업데이트
```

이 아키텍처는 UI와 비즈니스 로직을 명확히 분리하여 확장성과 유지보수성이 높은 애플리케이션을 구축하는 기반이 됩니다.

# Agent 특별 요구사항
// ... 기존 내용 ...


## 라우팅 관련

1. 페이지 정보 처리
   - 라우트 정보에 category 필드를 포함하여 하드코딩
   - `useCurrentPage` 훅을 통해 현재 페이지의 모든 정보(카테고리 포함) 직접 참조
   - 문자열 파싱이나 조건문 없이 타입 안전한 방식으로 카테고리 정보 사용

## 코드 구조화

1. 커스텀 훅 활용
   - 공통적으로 사용되는 로직은 커스텀 훅으로 분리하여 재사용성 높이기
   - 라우팅 관련 로직은 `routerUtils.ts`에서 관리

2. 정적 에셋 관리
   - 이미지와 같은 정적 에셋은 `import` 구문을 사용하여 모듈로 가져와야 함
   - 이는 Vite와 같은 번들러가 에셋을 올바르게 처리하고 빌드에 포함시키도록 보장함

## 컴포넌트 설계 원칙

1. 관심사 분리
   - 라우팅 로직은 라우터 유틸에서 관리
   - 컴포넌트는 UI 렌더링과 상태 관리에 집중

## 스타일링 규칙

1. 스타일 네이밍
   - 컴포넌트 props와 스타일 이름이 충돌하지 않도록 구분된 이름 사용
   - 스타일 용도를 명확히 하는 접미사 사용 (예: totalAmountText)
   - 컨테이너성 요소는 Container 접미사 사용 (예: orderItemsContainer)

2. CSS-in-JS 스타일 관리
   - Vanilla Extract 사용시 style() 함수로 스타일 정의
   - 모든 스타일은 별도의 .css.ts 파일에서 관리
   - 재사용 가능한 스타일은 공통 스타일로 분리

## 타입 안전성

1. 타입 정의
   - 인터페이스에 선택적 속성은 명확히 표시 (예: allergens?: string[])
   - Union 타입 사용시 제한된 값만 허용 (예: temperature: 'hot' | 'cold')
   - 타입 변환이 필요한 경우 명시적으로 처리 (예: 'both' → 'hot')

## 접근성 (A11y)

1. 키오스크 접근성 고려
   - 화면 읽기 프로그램 지원
   - 키보드 네비게이션 지원
   - 적절한 ARIA 레이블 사용
